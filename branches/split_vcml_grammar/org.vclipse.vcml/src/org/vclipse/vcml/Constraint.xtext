grammar org.vclipse.vcml.Constraint with org.eclipse.xtext.common.Terminals

import "platform:/resource/org.vclipse.vcml.mm/src/org/vclipse/vcml/mm/VCML.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

ConstraintSource hidden (WS, DEPENDENCY_COMMENT)
	:   'objects' ':'	objects+=ConstraintObject (',' objects+=ConstraintObject)* '.'?

		('condition' ':' condition=Condition '.'?)?

		('restriction' | 'restrictions') ':'
		restrictions+=ConditionalConstraintRestriction (',' restrictions+=ConditionalConstraintRestriction)*
		'.'?

		('inferences' ':' inferences+=CharacteristicReference (',' inferences+=CharacteristicReference)* '.'?)?
    ;

ConstraintObject
	:	ConstraintClass
	|	ConstraintMaterial 
	;
	
ConstraintClass
	:	(name=SHORTVAR 'is_a')? class=[Class|CLASSNAME] 
		(	'where'
			shortVars+=ShortVarDefinition (';' shortVars+=ShortVarDefinition)*
		)?
	;

ConstraintMaterial
	:	(name=SHORTVAR 'is_object')? objectType=ObjectType
		(	'where'
			shortVars+=ShortVarDefinition (';' shortVars+=ShortVarDefinition)*
		)?
	;

ObjectType
	:	'(' type='material' ')' '(' classType=INT ')' '(' attrs+=PartialKey (',' attrs+=PartialKey)* ')'
	;

 // TODO how to handle cross references?
PartialKey
	:	name='nr' '=' value=SYMBOL
	;

ShortVarDefinition
	:	name=SHORTVAR '=' characteristic=[Characteristic | XID]
	;

PartOfCondition :
	'part_of' '(' child=[ConstraintObject | SHORTVAR] ',' parent=[ConstraintObject | SHORTVAR] ')'
	; 
SubpartOfCondition :
	'subpart_of' '(' child=[ConstraintObject | SHORTVAR] ',' parent=[ConstraintObject | SHORTVAR] ')'
	; 

ConditionalConstraintRestriction returns ConstraintRestriction :
	ConstraintRestrictionLHS ({ConditionalConstraintRestriction.restriction=current} 'if' condition=Condition)?
	;

ConstraintRestrictionFalse
	:	{ConstraintRestrictionFalse}
	   'false'
	;

ConstraintRestrictionLHS returns ConstraintRestriction
	:	InCondition
	|	IsSpecified
	|	PartOfCondition
	|	SubpartOfCondition
	|	Comparison
	|	Table
	|	Function
	|	NegatedConstraintRestrictionLHS
	|	ConstraintRestrictionFalse
	;
	
NegatedConstraintRestrictionLHS
	:	'not' restriction=(Table | Function)
	;

/*
EqualsRestriction :
	characteristic=CharacteristicReference '=' expression=Expression
	;
*/

CharacteristicReference returns CharacteristicReference_C
	:	ObjectCharacteristicReference
	|	ShortVarReference
	;
	
ObjectCharacteristicReference
	:	location=[ConstraintObject | SHORTVAR] '.' characteristic=[Characteristic|XID]
	;

ShortVarReference
	:	ref=[ShortVarDefinition | SHORTVAR]
	;

Function returns Function
	:	'function' function=[VariantFunction|XID]
		'('
			characteristics+=[Characteristic|XID] '=' values+=Literal
			(',' characteristics+=[Characteristic|XID] '=' values+=Literal)*
		')'
	;

Table returns Table
	:	'table' table=[VariantTable|XID]
		'('
			characteristics+=[Characteristic|XID] '=' values+=Literal
			(',' characteristics+=[Characteristic|XID] '=' values+=Literal)*
		')'
	;
	
///////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////

Expression returns Expression
    :	MultiplicativeExpression ({BinaryExpression.left=current} operator=("+" | '-') right=MultiplicativeExpression)*
	;
	
MultiplicativeExpression returns Expression
	:	UnaryPrimaryExpression ({BinaryExpression.left=current} operator=('*' | '/' | '||') right=UnaryPrimaryExpression)*
    ;

UnaryPrimaryExpression returns Expression
	:	UnaryExpression
	|	PrimaryExpression
	;

UnaryExpression returns UnaryExpression
	:	operator=UnaryExpressionOperator expression=UnaryPrimaryExpression
	;
	
PrimaryExpression returns Expression
	:	'(' Expression ')'
	|	Literal
	|	FunctionCall
	;	

Literal returns Literal
	:	CharacteristicReference
	| 	MDataCharacteristic
	|	NumericLiteral
	|	SymbolicLiteral
	;

FunctionCall returns FunctionCall
	:	function=FunctionName '(' argument=Expression ')'
	;

MDataCharacteristic returns MDataCharacteristic_C
	:	'mdata' characteristic=CharacteristicReference
	;

NumericLiteral :
	value=NUMBER
	;

SymbolicLiteral :
	value=SYMBOL
	;

///////////////////////////////////////////////////////////////////////////////
// Conditions
///////////////////////////////////////////////////////////////////////////////

Condition returns Condition
	:	Conjunction ({BinaryCondition.left=current} operator='or' right=Conjunction)* 
	; 

Conjunction returns Condition
	:	Negation ({BinaryCondition.left=current} operator='and' right=Negation)*
	; 

Negation returns Condition
	:	UnaryCondition
	|	PrimaryCondition
	;

UnaryCondition returns UnaryCondition
	:	'not' condition=Negation // not may be nested in constraints
	;

// TODO not must not be used around specified, part_of and subpart_of - put into validation

PrimaryCondition returns Condition
	:	Comparison
	|	'(' Condition ')'
 	|	InCondition
 	|	IsSpecified
 	|	PartOfCondition
	|	SubpartOfCondition 
	;

Comparison returns Comparison
	:	left=Expression operator=ComparisonOperator right=Expression
	;

IsSpecified returns IsSpecified_C
	:	characteristic=CharacteristicReference 'specified'
	|	'specified' characteristic=CharacteristicReference
    ;

InCondition returns InCondition_C
	:	characteristic=CharacteristicReference 'in' list=List
	;

List :
		NumberList
	|	SymbolList
	;

NumberList :
	'(' entries+=NumberListEntry (',' entries+=NumberListEntry)* ')'
	;

NumberListEntry :
	  NumericLiteral
	| NumericInterval
	;
	
NumberListEntryForValues returns NumberListEntry :
	  NumericLiteral
	| '(' NumericInterval ')'
	;
	
NumericInterval :
	lowerBound=NUMBER '-' upperBound=NUMBER
	;

SymbolList :
	'(' entries+=SymbolicLiteral (',' entries+=SymbolicLiteral)* ')'
	;

enum UnaryExpressionOperator :
	PLUS  = '+' | 
	MINUS = '-' | 
	LC = 'lc' |
	UC = 'uc'
	;

enum ComparisonOperator : 
	EQ = '='  | EQ = 'eq' |
	NE = '<>' | NE = 'ne' |
	GT = '>'  | GT = 'gt' |
    GE = '>=' | GE = '=>' | GE = 'ge' |
	LT = '<'  | LT = 'lt' |
	LE = '<=' | LE = '=<' | LE = 'le'
	;
	
enum FunctionName :
		SIN    = 'sin'
	|	COS    = 'cos'
	|	TAN    = 'tan'
	|	EXP    = 'exp'
	|	LN     = 'ln'
	|	ABS    = 'abs'
	|	SQRT   = 'sqrt'
	|	LOG10  = 'log10'
	|	ARCSIN = 'arcsin'
	|	ARCCOS = 'arccos'
	|	ARCTAN = 'arctan'
	|	SIGN   = 'sign'
	|	FRAC   = 'frac'
	|	CEIL   = 'ceil'
	|	TRUNK  = 'trunk'
	|	FLOOR  = 'floor'
	;

terminal ID	// Xtext standard without ^ 
	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
	;

terminal DEPENDENCY_COMMENT
	:	(' '|'\t')* ('\r'? '\n*') !('\n'|'\r')*
	;

terminal SYMBOL // enclosed in single quotes, no escapes, no line breaks, no tabs
	:	"'" ( !("'"|'\t'|'\n'|'\r') )* "'"
	; 

XID
	:	ID
	|	'AF'
	|	'AR'
	|	'BG'
	|	'CA'
	|	'CS'
	|	'DA'
	|	'DE'
	|	'EL'
	|	'EN'
	|	'ES'
	|	'ET'
	|	'FI'
	|	'FR'
	|	'HE'
	|	'HR'
	|	'HU'
	|	'ID'
	|	'IS'
	|	'IT'
	|	'JA'
	|	'KO'
	|	'LT'
	|	'LV'
	|	'MS'
	|	'NL'
	|	'NO'
	|	'PL'
	|	'PT'
	|	'RO' 
	|	'RU'
	|	'SH'
	|	'SK'
	|	'SL'
	|	'SR'
	|	'SV'
	|	'TH'
	|	'TR'
	|	'UK'
	|	'Z1'
	|	'ZF'
	|	'ZH'
	|	'e'
	;

EXTENDED_ID
	: XID
	| SYMBOL
	;
//EXTENDED_ID hidden () // no whitespace might be used inside extended ids
//	:	(INT | ID | '/' | ':' | '-' | '.')+ 
//	;	

// bug has been filed as Xtext bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=303212
SHORTVAR // NOTE: due to a bug in Xtext, the following does not work: hidden () // no whitespace might be used inside shortvars // TODO verify this in SAP
	:	('?' | '#')? XID 
	;	

// TODO implement size restrictions for a number: e.g., the exponent's maximum value is 99
NUMBER hidden ()
	:	('-'|'+')? INT ('.' INT)? ('e' ('-'|'+') INT)? // sign of exponent is mandatory in SAP
	;

/*
TODO:
 * handle characteristics with hyphens in their name. Use in dependencies code as: skey 'cstic-name-with-hyphens'
 * handle keywords 'INVISIBILITY', 'INV', 'SKEY'
 * handle intervals with "bound operators", e.g., >1 - <5
*/

CLASSNAME
	:	'(' INT ')' XID
	;

