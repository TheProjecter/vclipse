#summary VCML Language Documentation
#labels Featured,Phase-Design
#sidebar TableOfContents
<wiki:toc max_depth="4" />

= VCML Documentation =

_Please note that this documentation is still incomplete._
_Meanwhile, you can have a look into the parser definition file [http://code.google.com/a/eclipselabs.org/p/vclipse/source/browse/org.vclipse.vcml/src/org/vclipse/vcml/VCML.xtext VCML.xtext]_

Please note that this document is _not_ an introduction into SAP Variant Configuration.
The [http://help.sap.com/printdocu/core/print46c/en/data/pdf/LOVC/LOVC.pdf official documentation by SAP on LO-VC] or the book [http://www.sap-press.com/products/Variant-Configuration-with-SAP-(2nd-Edition).html Variant Configuration with SAP] by Uwe Blumöhr, Manfred Münch, and Marin Ukalovic
as well as the SAP training courses provide introductory as well as in-depth information. 

== Introduction to VCML Model Structure ==

VCML provides a textual language to represent complete product models of the SAP Variant Configurator (LO-VC) or SAP IPC.

VCML source code is organized in two different kinds of files:
 * files with extension {{{.vcml}}} contain all objects of a product model, e.g., characteristics, classes, configuration profiles, or dependency nets. 
 * files with extensions {{{.cons}}}, {{{.proc}}}, {{{.sel}}}, and {{{.pre}}} contain the source code of dependencies of type _constraint_, _procedure_, _selection condition_, and _precondition_, respectively, in the respective language for dependencies as defined by SAP. These files have to be located in a dedicated sub folder: for a VCML file with name {{{FILENAME.vcml}}}, the dependency files have to be located in a folder {{{FILENAME-dep}}}. The name of the dependency source-code file must be the same as the name of the dependency, with the respective extension given above.

In the following the VCML file structure and the VCML-specific language syntax is described. 
Each {{{.vcml}}} file contains the textual representation of a VCML model. It is built of three basic building blocks: imports, options, and definitions of VC objects, as shown below:

{{{
VcmlModel :	
	Import*
	('options' '{' Option* '}')?
   	VCObject*
}}}

Note that these building blocks must be entered in the given order.

== Imports ==

The model can contain several import statements to import VC objects from other {{{.vcml}}} files.
The VC objects in the imported VCML files are then visible inside the importing VCML file. 

Applications:
 * Re-use of common data: information which is required for several or even all models can be stored in a central place and reused  wherever it is needed/applicable.
 * Create variants of a model: you can create variants of an existing model by importing the complete model and just modify several dedicated definitions. The original model is preserved. 
   Note: In this case all modifications done in the original model will automatically apply to the variant, too.

{{{
Import :
	'import' String
}}}
    
The import statement consists of the keyword 'import', followed by a String. This string represents the path to the source of the file or data which is to be imported. 
The path can be given as absolute path or as relative path with respect to the {{{.vcml}}} file.

Example of an import statement with absolute path:
{{{
import "platform:/resource/PROJECTNAME/FOLDERNAME/FILENAME.vcml"
}}}

Example of an import statement with relative path:
{{{
import "../../FOLDERNAME/FILENAME.vcml"
}}}

== Options ==

Optionally, a VCML model can contain one or more options. These options influence how objects are processed.

{{{
Option :
	Optiontype '=' String
}}}

An option definition starts with the option type, the equals '=' symbol, and the value of the option, given as a String.

Currently, the following options are defined:
 * {{{UPS}}}: When IDocs are created from the VCML document, the value of the UPS option is used as object key for the generated ALE distribution packet.
 * {{{ECN}}}: The value of the UPS option is used as change number for all objects.
 * {{{KeyDate}}}: The value of the KeyDate option is used as key date for all object.
 
== VC Objects ==

Each file can contain several top level VC objects.

=== Declaration of VC Objects ===

In the {{{.vcml}}} file the following kinds of VC objects can be defined:

{{{
VCObject : 
		BillOfMaterial
	|	Characteristic
	| 	Class
	| 	ConfigurationProfile
	| 	Constraint 
	| 	DependencyNet
	| 	InterfaceDesign
	| 	Material
	| 	Precondition 
	| 	Procedure 
	| 	SelectionCondition 
	| 	VariantFunction
	| 	VariantTable
	| 	VariantTableContent
}}}
	
The following table gives a short information about the purpose of each kind of VC object. For detailed information see the dedicated chapters in the [VCMLLanguage#List_of_VC_Objects].
|| *VC Object* || *Purpose* ||
|| [VCMLLanguage#Bill_of_Material Bill of Material] || The BOM contains all items (materials) which are required to cover all variants of the product and assigns them to the product model. ||
|| [VCMLLanguage#Characteristic Characteristic] || The characteristics precisely define all selectable options or features of a configurable product, together with their feature values. Characteristics can be assigned object dependencies and/or restrictions to ensure that the configurations are consistent and complete, i.e. they only contain valid combinations of features and feature values. Characteristics can be used for static information (display only) as well as for variable options. These variable options again may or may not allow user input. ||
|| [VCMLLanguage#Class Class] || In the standard SAP R/3 the class type 300 is the class type for variants. In the {{{.vcml}}} file all characteristics defined for the product model are assigned to this class to enable their usage for material configuration.||
|| [VCMLLanguage#Configuration_Profile Configuration Profile] || The configuration profile is mandatory for each configurable object. It contains general settings, like the product material??, the user interface design as well as standard networks (NPs) ?? and general procedures (PPs)?? which are to be used.Dependencies are also defined in the configuration profile.  The definitions depend on the object type. ||
|| [VCMLLanguage#Constraint Constraint] || Constraints monitor the consistency of a configuration. They describe dependencies between characteristics and contain information on which conditions must be fulfilled if the configuration is to be consistent.According to Sap R/3 constraints must belong to a dependency net. ||
|| [VCMLLanguage#Dependency_Net Dependency Net] || The dependency net groups all constraints for the product model and provides like a single point of entry to the constraints of the whole configuration. ||
|| [VCMLLanguage#Interface_Design Interface Design] || The interface design supports grouping of characteristics to enable a structured layout. ||
|| [VCMLLanguage#Material Material] || Material is used to define name and type of every single configurable item of the product. Additionally, with material general features/relations?? Like type, assigned bill of materials, classes and configuration profiles which are used for the model are defined. ||
|| [VCMLLanguage#Precondition Precondition] || Preconditions support restricting or hiding of characteristics or characteristic values in case that they are only valid if the precondition is fulfilled. This ensures that configuration is consistent. ||
|| [VCMLLanguage#Procedure Procedure] || Procedures allow to internally/automatically modify values in the model. They can be assigned to characteristics, characteristic values, the configuration profile, BOM items and operations, which will then trigger a specified value change.||
|| [VCMLLanguage#Selection_Condition Selection Condition] || The assignment of a selection condition ensures that all objects required for a variant are selected. It can be assigned e.g. to characteristics and BOM items.  ||
|| [VCMLLanguage#Variant_Function Variant Function] ||  ||
|| [VCMLLanguage#Variant_Table Variant Table] || A variant table supports restriction of characteristic values to valid combinations.  ||
|| [VCMLLanguage#Variant_Table_Content Variant Table Content] || Here the content of a variant table is defined.||

The minimum requirement for a configurable product is the definition of the material (for the product itself as well as for the individual items), a characteristic with selectable values and the assignment of a class and a configuration profile. By adding additional characteristics and other kinds of VC objects any product however complex can be modeled for variant configuration.

Each declaration of a VC object itself consists of the dedicated keyword as listed above, followed by the mandatory assignment of a name, and an optional body. 
The body can contain other objects or references to other VC objects defined elsewhere in the {{{.vcml}}} file.
There are some basic sublevel objects/features that are used in a number of VC objects while most sublevel objects/features are specific to a VC object. 
The identifiers and sublevel objects/features themselves are separately declared later on in the vcml file. Using this hierarchical declaration structure, all identifiers and sub level objects/features are defined only once and can be used/referenced by all other objects and VC objects.
For more information on the identifiers syntax and usage for the different VC objects see [VCMLLanguage#Identifier].
For more information on the common basic objects see [VCMLLanguage#Basic_options/Features].
For the declaration of the sublevel objects/features specific to VC objects, see the [VCMLLanguage#List_of_VC_Objects]. 

==== Descriptions ====

Nearly each VC object has a description.
Descriptions can be single-language descriptions or multi-language descriptions.

{{{
Description:
	SimpleDescription | MultiLanguageDescriptions
}}}

A single-language description is written as follows:
{{{	
SimpleDescription:
	'description' String
}}}

A multi-language description contains descriptions for multiple languages:
{{{
MultiLanguageDescriptions:
	'description' '{' (Language String)* '}'
	
Language:
	  AF | AR | BG | CA | CS | DA | DE | EL | EN | ES | ET | FI | FR | HE
	| HR | HU | ID | IS | IT | JA | KO | LT | LV | MS | NL | NO | PL | PT
	| RO | RU | SH | SK | SL | SR | SV | TH | TR | UK | Z1 | ZF | ZH
}}}
All SAP-supported ISO language codes can be used. 

An example for a single-language description is
{{{
description "the description of the VC object"
}}}

An example for a multi-language description is
{{{
description {
  EN "the description of the VC object"
  DE "die Beschreibung des VC-Objekts"
}
}}}

In the case of single-language descriptions, the default language defined in VClipse preferences is used, if specified. Otherwise the English language is used (EN).

Please note that descriptions are limited to 30 characters.
In case longer texts are required, you can use documentations.

==== Documentation ====

Several VC objects have a documentation.
Documentations can be single-language documentations or multi-language documentations.

{{{
Documentation:
	SimpleDocumentation | MultiLanguageDocumentations
}}}

A single-language documentation is written as follows:
{{{	
SimpleDocumentation:
	'documentation' String
}}}

Multi-language documentations are slightly more complicated than descriptions, since documentations may contain
multiple text blocks with attached format information.

Multi-language documentations contain documentations for multiple languages:
{{{
MultiLanguageDocumentations:
	'documentation' '{' (Language String ('format' String)? )* '}'
}}}

An example for a single-language documentation is
{{{
documentation "the documentation of the VC object"
}}}

An example for a multi-language documentation is
{{{
documentation {
  EN "the documentation of the VC object"
  DE "die Dokumentation des VC-Objekts"
}
}}}

<wiki:comment>
### give another example which uses format
</wiki:comment> 

{{{
documentation {
  EN "the documentation of the VC object" 
  DE "die Dokumentation des VC-Objekts"
}
}}}

In the case of single-language documentations, the default language defined in VClipse preferences is used, if specified. Otherwise the English language is used (EN).

==== Status ====

Many VC objects can have a status.

A status is written as follows:
{{{	
Status:
	'status' ('released' | 'inPreparation' | 'locked')
}}}

An example for a status is
{{{
status released
}}}

==== Group ====

These VC objects can also be assigned to groups.
In the SAP systems, groups are defined in customization and thus have a restricted range of possible values.
In VCML, they are written as strings and are therefore not restricted.

A group is written as follows:
{{{
Group:
	'group' String
}}}

An example for a group is
{{{
group "PRODUCTS_CAR"
}}}

The length of a group is restricted to 10 characters.

== List of VC objects ==
??Additionally, one or more objects have to be assigned with VC objects, which in turn can contain (sub level) objects or reference to other top level VC objects.
//VC objects ohne body sind z.B. für generische 
=== Characteristic ===
Characteristics are used to describe precisely of which elements a product is made of, and which values these elements can have.

A characteristic is written as follows:
{{{
Characteristic =
  'characteristic' EXTENDED_ID ( '{'
     Description
	 Documentation?
	 CharacteristicType
     Status?
   	 Group?
	 CharacteristicAdditionalProperties?
	 CharacteristicOrValueDependencies?
  '}' )? 	

CharacteristicAdditionalProperties = 
  '[' 'additionalValue'?
      'required'?
      'restrictable'?
      'noDisplay'?
      'notReadyForInput'?
      'multiValue'?
      'displayAllowedValues'?  
  ']'
}}}

Currently, only numeric and symbolic characteristics are possible.
The other characteristic types possible in SAP like date or ADT are not yet implementd in VCML.

{{{
CharacteristicType = NumericType | SymbolicType
}}}

A !NumericType is written as follows:
{{{	
NumericType =
  'numeric' '{'
     'numberOfChars' INT
     'decimalPlaces' INT
	 ('unit' String)?
     NumericAdditionalProperties?
     ('values' '{' NumericCharacteristicValue* '}' )?
  '}'

NumericAdditionalProperties = 
  '[' 'negativeValuesAllowed'?
      'intervalValuesAllowed'?  
  ']'

NumericCharacteristicValue = NUMBER CharacteristicOrValueDependencies?
}}}

A !SymbolicType is written as follows:
{{{	
SymbolicType =
  'symbolic' '{'
     'numberOfChars' INT
     SymbolicAdditionalProperties?
     ('values' '{' CharacteristicValue* '}' )?
  '}'

SymbolicAdditionalProperties = 
  '[' 'caseSensitive'? ']'

CharacteristicValue =
  SYMBOL ('{' 
    Description? 
    Documentation? 
    CharacteristicOrValueDependencies?
  '}')?
}}}

An example for a characteristic is
{{{
characteristic ENGINE {
  description "the possible engines for a car"
  numeric { 
    numberOfChars 4
    decimalPlaces 0
    values {1500 1800 2100 2400}
  } 
  status released
  group "PRODUCTS_CAR"
}
}}}

Dependencies, i.e. conditions, procedures, or constraints can be attached to characteristics or characteristic values.

CharacteristicOrValueDependencies are written as follows:
{{{	
CharacteristicOrValueDependencies =
  'dependencies' '{'
     ID*
  '}'
}}}
The {{{ID}}} name the attached depedencies.

<wiki:comment>
### This is an example for local dependencies
An example for CharacteristicOrValueDependencies is:
{{{
	dependencies {
		precondition {
            description "precondition for gears"
            PRODUCTS_CAR
            source { $SELF.GEAR in ('4-gear', '4-gear automatic')       
                       if $ROOT.ENGINE IN ('1500', '1800') 
                    }		
        }
		
		selectioncondition {
            description "selection condition for gears"
            source { $SELF.GEAR SPECIFIED 
                     if $ROOT.ENGINE SPECIFIED 
            }
        }
		
		// global dependencies like procedure, selection condition, or precondition 

		PRECOND  // see [VCMLLanguage#Precondition]
		SEL_COND // see [VCMLLanguage#Selection_Condition]
	}
}}}
</wiki:comment>

=== Class ===

The main purpose of classes is to reference characteristics and attach them to materials of the model, see also [VCMLLanguage#Material Material]. 

A class is defined as follows:

{{{
Class :
	'class' CLASSNAME ('{'
		Description
    	Status?
    	Group?
    	'characteristics' '{' EXTENDED_ID* '}'
    	('superclasses' '{' CLASSNAME* '}')?
	'}')?

CLASSNAME = '(' INT ')' EXTENDED_ID
}}}

A class definition starts with the keyword {{{class}}} followed by a {{{CLASSNAME}}}. 
The {{{CLASSNAME}}} consists of an integer number set in brackets defining the class type and an {{{XID}}} defining the name of the class.
The class type must be valid for usage in variant configuration, like (300).

The class can be enhanced by an optional body.
If the body is added, a {{{Description}}} is a mandatory feature while {{{Status}}} and {{{Group}}} are optional.
All {{{characteristics}}} must be referenced here with their name, textually represented as an {{{XID}}}.
The number of characteristics in one class is restricted to 999. This total number of characteristics can be extended by adding references to superclasses, since a class inherits all characteristics of its superclasses.
The {{{superclasses}}} can be referenced with their {{{CLASSNAME}}} which is defined as described above.
The entries for the optional features in the body can be made in any order.

A class definition without body can be used e.g. to include general classes in the product model which are defined somewhere else.

Example for a class definition without body stating only the classname:

{{{
class (300)CAR
}}}

Example for a class definition with body, including all optional features:

{{{
class (300)CAR {
	description "this is the class for the car"
	status released
	group "PRODUCTS_CAR"
	characteristics {
		ENGINE
		GEAR
		COLOUR
		INTERIOR
	}
	superclasses { (300)VEHICLE }
}
}}}

=== Constraint === 

A constraint is defined as follows:
{{{
Constraint =
  'constraint' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConstraintSource '}' )?
  '}')?  
}}}

{{{ConstraintSource}}} is the source code of the constraint.
The syntax of the source code is exactly defined like in SAP.

Example for a constraint declaration:
{{{
constraint CS_CAR1 {
  description "Possible interior for the smallest engine"
  status released
	group "PRODUCTS_CAR"
	source {
	  OBJECTS: CAR IS_A (300)CAR
      CONDITION: CAR.ENGINE = '1500'
      RESTRICTION: CAR.INTERIOR IN ('01', '02')
	}
  }
}}}

=== Dependency Net ===
A dependency net is defined as follows:
{{{
DependencyNet =
  'dependencynet' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ID*
  '}')?  
}}}

The first ID defines the name of the dependency net,
the second ID are the names of the constraints of the dependency net.

Example for a dependency net declaration:
{{{
dependencynet DEP_NET {
  description "This is a constraint net for the car"
  documentation "documentation"
  status released
  group "PRODUCTS_CAR"
  CSTRT
  CS_CAR1
}
}}}

=== Interface Design === 
An interfacedesign is defined as follows:
{{{
InterfaceDesign =
  'interfacedesign' EXTENDED_ID ('{'
    CharacteristicGroup*
  '}')?  

CharacteristicGroup =
  'characteristicgroup' EXTENDED_ID '{'
    Description
    ID*
  '}'
}}}

The ID in a characteristic group refers to a characteristic.

Example for an interface design declaration:
{{{
  interfacedesign INT_DESIGN {
	characteristicgroup FunEl {
	  description "functional elements"
	  ENGINE
      GEAR
    }
	characteristicgroup DesignEl {
      description "design elements"
      COLOUR
      INTERIOR
    }
  }
}}}

=== Material === 

A material is used to define name and type of both a whole product which itself consists of several configurable items as well as every single line item.
For example both the car and all available parts as engines, gears, colors, etc. are declared as material. 
For product material, besides name and type general features can be added, like the assignment of classes, classification, bill of materials, and configuration profiles which apply to the product.
Please note, that material objects have no documentation, group, and status features. 

A material is defined as follows:

{{{ 
Material :
	'material' EXTENDED_ID ('{'
		Description
		type EXTENDED_ID
		'billofmaterials' '{' EXTENDED_ID* '}'?
		'classes' '{' Classification* '}'?
		'configurationprofiles' '{' EXTENDED_ID* '}'?
	'}')?

Classification
	CLASSNAME ('{' ValueAssignment* '}')?

ValueAssignment :
	EXTENDED_ID* '=' (NumericLiteral | SymbolicLiteral)+
}}}

A material definition starts with the keyword {{{material}}} followed by an {{{EXTENDED_ID}}} defining the name of the material.

The material definition can be enhanced by an optional body.

If the body is added, {{{description}}} and {{{type}}} are mandatory features. The type is defined by an identifier ({{{ID}}}), typical types are {{{KMAT}}} (configurable material) or {{{HAWA}}} (trading goods).
Additionally, {{{billofmaterials}}}, {{{configurationprofile}}} and {{{classes}}} can be referenced. 
These features are required when specifying the material of a complete product, see also example below.

By referencing the bill of material all configurable items available for the product are assigned to the product as BOM items. Thus the bill of material is like a master BOM. The items valid for a specific variant configuration are picked from this master BOM.
For detailed information see [VCMLLanguage#Bill_of_Material Bill of Material].
Adding configuration profiles to a material allows to define general settings and further object dependencies. For detailed information see [VCMLLanguage#Configuration_Profile Configuration Profile].
The references to classes allow to classify the product material with a set of classes. Additionally, values can be assigned to characteristics by means of classification.

The entries for the optional features in the body can be made in any order.

Example for a material definition for a product, i.e. including a bill of material, a class, and a configuration profile:

{{{ 
material CAR {
	description "A configurable car"
	type KMAT
	classes { (300)CAR }
	billofmaterials { 'bom_car' }
	configurationprofiles { 'profile_car' }
}
}}}

Example for a material definition for line items without any optional features:

{{{
material Engine_1500 {
	description "Small engine"
	type HAWA
}

material Engine_2400 {
	description "Big engine"
	type HAWA
}
}}}

=== Bill of Material ===

The bill of material is a list of configurable items.
The bill of material must be defined for the complete product, which is then the master BOM for all product variants. 
This master BOM can directly list every single item of the product, see example 1, or list other BOMs for groups of items, like BOMs for engine, gear, etc. as shown in example 2. 
You can also mix single items and BOMs in a BOM definition.
To distinguish between mandatory material and variable, i.e. configurable material, the object/feature selection condition is used. 
Declaration of a selection condition makes the material a variable part, i.e. it will only be added to the product if a specified condition is fulfilled. 

A bill of material is defined as follows:

{{{
BillOfMaterial :
	'billofmaterial' EXTENDED_ID ('[' Option* ']')? '{'
		'material' '{'EXTENDED_ID'}?
		'items' '{' BOMItem* '}'?
	'}'

BOMItem :
	BOMItem_Material | BOMItem_Class

BOMItem_Material :
	INT EXTENDED_ID
	('dependencies' '{'
		EXTENDED_ID?					//selection condition??
	 	ConfigurationProfileEntry*
	'}')?

BOMItem_Class :
	INT CLASSNAME
	('dependencies' '{'
		EXTENDED_ID?					//selection condition??
	 	ConfigurationProfileEntry*
	'}')?
}}}

The bill of material starts with the keyword {{{billofmaterial}}} followed by the name of the bill of material, textually represented as an {{{EXTENDED_ID}}}, and the features.

The bill of material definition can be enhanced by an optional body with two optional features, {{{material}}} and {{{items}}}.
The material referenced here is the material of the product, consisting of the keyword {{{material}}} followed by the name of the corresponding material.
The feature items consists of the keyword {{{items}}} followed by a list of all BOM items, i.e. all configurable items belonging to the product.

BOM items can either be materials or classes (class nodes). Their definition starts with an integer number {{{INT}}}, representing the item number. This is followed by the name of this dedicated item, textually represented as an {{{EXTENDED_ID}}} for materials or the {{{CLASSNAME}}} for classes.

Add info on when to select which type!

Optionally, {{{dependencies}}} can be added giving the reference to a selection condition, see [VCMLLanguage#Selection_Condition Selection Condition], and to procedures using {{{ConfigurationProfileEntry}}}, see [VCMLLanguage#Configuration_Profile Configuration Profile].

Example 1 for BOM with single items:

{{{
billofmaterial 'bom_car' {
	material 'CAR'
	items {
	  10	Engine_1500
	  dependencies {  sel cond. and/or procedure	}	  ???
	  20	Engine_1800
	   dependencies {    ??	 }	  ???
	  30	Engine_2100
	   dependencies {    ??	 }	  ???
	  40	Engine_2400
	   dependencies {    ??	 }	  ???
	  50	Gear_4
	  60	Gear_4automatic
	  70	Gear_5
	  80	Gear5automatic
	  90	Interior_01
	  100	Interior_02
	  110	Interior_03
	  120	Colour_black
	  130	Colour_white
	  140	Colour_red
	}
  }
}}}
Example 2 for BOM with further BOMs and single items:
{{{
billofmaterial 'bom_car' {
	material 'CAR'
	items {
	  10	bom_engine
	  20	bom_gear
	  30	bom_interior
	  40	bom_colour
	  50	stereo
	  60	navigation system
	}
  }
  billofmaterial 'bom_engine' {
	material 'engine'
	items {
	  10	Engine_1500
	  dependencies {    ??	}	 ???
	  20	Engine_1800
	   dependencies {    ??	 }	  ???
	  30	Engine_2100
	   dependencies {    ??	 }	  ???
	  40	Engine_2400
	   dependencies {    ??	 }	  ???
	}
  }
  billofmaterial 'bom_gear' {
	material 'gear'
	items {
	  10	Gear_4
	  20	Gear_4automatic
	  30	Gear_5
	  40	Gear5automatic
	}
  }
  billofmaterial 'bom_interior' {
	material 'interior'
	items {
	  10	Interior_01
	  20	Interior_02
	  30	Interior_03
	}
  }
    billofmaterial 'bom_colour' {
	material 'colour'
	items {
	  10	Colour_black
	  20	Colour_white
	  30	Colour_red
	}
  }
}}}

=== Configuration Profile ===

The configuration profile is defined as follows:
{{{
ConfigurationProfile 
	:
    'configurationprofile' EXTENDED_ID ('[' options+=Option* ']')? '{'
	   (	('material' '{'EXTENDED_ID'})?
	   		('status' Status)?
	   		('bomapplication' EXTENDED_ID)?
	   		('uidesign' '{'EXTENDED_ID'})?
	    	('fixing' Fixing)?
	   )
       ('DependencyNet' '{'EXTENDED_ID'}])*
       (ConfigurationProfileEntry)*
    '}'
    
ConfigurationProfileEntry :
    INT EXTENDED_ID
             
}}}  
The configuration profile starts with the keyword {{{'configurationprofile'}}}, followed by the name of the profile, textually represented as an {{{EXTENDED_ID}}}, and the features.  
Optionally, the material of the product and a ui design can be referenced, and a status, a BOM application and a Fixing can be defined.
Describe bom application!
Describe fixing!
Additionally, dependency nets are referenced and configuration profile entries ?? listed.
The configuration profile entry is defined by an integer referring to the sequence of the entry and a reference to a procedure, textually represented as an {{{EXTENDED_ID}}}, 

== Precondition ==
A precondition is defined as follows:
{{{
Precondition =
  'precondition' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConditionSource '}')?
  '}')?
}}}

ConditionSource is the source code of the precondition, exactly as defined in SAP.

An example for a precondition
{{{
precondition PRECOND {
  description "description"
  documentation "documentation"
  status released
  group "group"
  source { $SELF.GEAR in ('4-gear', '4-gear automatic')       
           if $ROOT.ENGINE IN ('1500', '1800') }
}
}}}

== Procedure ==
A procedure is defined as follows:
{{{
Procedure =
  'procedure' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ProcedureSource '}')?
 '}')?
}}}

ProcedureSource is the source code of the procedure, exactly as defined in SAP.

Example for a procedure:
{{{
procedure PROC {
  description "set interior quantity"
  documentation "documentation"
  status released
  group "PRODUCTS_CAR"
  source { $self.C_QUANT = 2 if $root.ENGINE = '1500' }
}
}}}

== Selection Condition == 
A selection condition is defined as follows:
{{{
SelectionCondition =
  'selectioncondition'  ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConditionSource '}')?
  '}')?
}}}

ConditionSource is the source code of the selection condition, exactly as defined in SAP.

Example for selection condition:
{{{
selectioncondition SEL_COND {
  description "description"
  documentation "documentation"
  status released
  group "group"
  source { $SELF.GEAR SPECIFIED if $ROOT.ENGINE SPECIFIED }
}
}}}

== Variant Function ==
Only the interface of a VariantFunction is defined here.
ABAP respectively Java code is not defined in VCML.

A variant function is defined as follows:
{{{
VariantFunction =
  'variantfunction'   ('{'
    Description
    Status?
    Group?
    ('arguments' '{' VariantFunctionArgument* '}' '}')?
    
VariantFunctionArgument = 'in'? ID
}}}

If the keyword {{{in}}} is given the following ID refers to an input characteristic.
Otherwise the ID belongs to an output characteristic.

Example for a variant function:
{{{
variantfunction VAR_FUNC {
  description "description"
  group "group"
  status locked
  arguments {
	in ENGINE 
	in GEAR 
	FUELCONSUMPTION   
  }
}
}}}

== Variant Table ==

The structure (scheme) of a variant table is defined as follows:
{{{
VariantTable =
  'varianttable' ID ('{'
    Description
    Status?
    Group?
    ('arguments' '{' VariantTableArgument* '}') '}')?
    
VariantTableArgument = 'key'? ID
}}}

The keyword {{{key}}} is used to mark the key columns. The ID refers the appropriate columns.

Example for a variant table:
{{{
varianttable VAR_TAB {
  description "description"
  group "group"
  status inPreparation
  arguments {
	key INTERIOR
	COLOUR
  }
}
}}}

== General Language Constructs ==

The VCMl language contains various general constructs providing basic definitions which are required repeatedly in a {{{.vcml}}} file.
Some constructs, like whitespace, empty lines or backspace?? support the structuring of the file to improve readability.
Another construct allows to make comments for additional information. These are not part of the model and will not be interpreted as code.
There are several constructs which define different kinds of character sequences, like for example strings, symbols, identifiers or even dedicated keywords, which can be assigned to object values or objects. 
Operators are also generally defined to support different kind of assignments between objects/features and object values.
For more information see also the Xtext grammar documentation under [http://www.eclipse.org/Xtext/documentation/2.3.0/Documentation.pdf].

=== Whitespace and Empty Line ===

Whitespace and empty lines can be inserted at any place in the {{{.vcml}}} file for better readability and structuring of the file content. 
Except for keywords which must be preceded and followed by a whitespace to be detectable, whitespace and empty lines are irrelevant for the model and not interpreted as code.

=== Comments ===

VCML offers single-line comments and block comments. The comment can start at any place in a line. They are written like in Java or C.
Single-line comments do start with {{{//}}} and automatically end with the end of the line.
Block comments start with {{{/*}}} and end with {{{*/}}}. They can but need not run over several lines. Block comments may not be nested.
Block comments not only allow to give detailed additional information but they can also be used for other purposes:
 * Enter incomplete definitions of objects as block comments which will be completed later and only then included in the model code.
 * Temporarily exclude parts of the model by enclosing it in the block comment syntax, without deleting it completely from the model.

Note that comments can not be used within Strings, see [VCMLLanguage#Strings Strings]

Examples for single-line comments:

{{{
// this is a single line comment, starting in the first column of the line
    // this is another single line comment which does not start in the first column
import "platform:/resource/PROJECTNAME/FOLDERNAME/FILENAME.vcml"	//This is an import with an absolute path. (=comment)
}}}

Examples for block comments:

{{{
/* this is a block comment
running over two lines
*/

import /*with an absolute path*/ "platform:/resource/PROJECTNAME/FOLDERNAME/FILENAME.vcml "

/*note, that the path has to be completed later on:
import "platform:/resource/??"
*/
}}}

=== Strings ===

Strings are character sequences enclosed in double quotes. They are used e.g. for description and documentation of objects/features. 
A string can even be empty. Escape sequences starting with {{{\}}} allow to write strings containing special characters, like the newline {{{\n}}} or tab character {{{\t}}} or the double quote character {{{\"}}}.
The contents of strings is case sensitive.

Sample strings are:
{{{
"" // the empty string
"A sample string"
"A SAMPLE STRING" // another sample string, different from the string before due to case sensitivity
"This is a tab\tand this is a newline\ncharacter" // a string containing special characters for tab and newline
"This is a string with a word written in \"quotes\""
"The backslash character itself can be escaped by writing it twice \\"
"The line comment character sequence // does not introduce a comment in strings"
}}}  

=== Identifier, Symbol, Extended Identifier and Classname===

These constructs are used to define names for objects/features. They allow to build names of different complexity with varying character sets.
Some dedicated character sequences are reserved as keywords and thus cannot be used as identifier, symbol or classname, see [VCMLLanguage#Keywords Keywords]. 

==== *Identifier* ====

The simplest construction is the identifier, which is a character sequence beginning with a lower/upper character (only 
ASCII characters are allowed) or underscore, which can be followed by further lower/upper characters, underscore 
or numbers in any order. Identifiers are case insensitive. 

Examples for valid simple identifiers:
{{{
_4gear
Engine_1500
wIndOWs_7
color
}}}

Examples for *invalid* simple identifiers:
{{{
4gear			//Number  not allowed as first character
Engine-1500		//- not allowed 
}}}

==== *Symbols* ====

To allow special characters like {{{:}}}, {{{-}}}, {{{+}}}, etc., or numbers at the first position in character sequences for names of objects/features, the whole character sequence has to be enclosed in siongle quotes.
This is called a symbol. Symbols are case-insensitive and can even be empty.
Note, that escape characters and single quote itself are not allowed.

Examples for valid symbols:
{{{
'4gear'
'Engine-1500'
'wIndOWs:7'
}}}

==== *Extended Identifier* ====

The extended identifier allows to use either an identifier or a symbol as a name and can be used for most objects/features, except e.g. for classes, see [VCMLLanguage#Classes Classes].
Extended identifier can not be empty. 

Examples for valid extended identifiers:
{{{
_4gear
Engine_1500
wIndOWs_7
color
'4gear'
'Engine-1500'
'wIndOWs:7'
}}}
  
==== *Classname* ====

The classname is a special construct to define the name of the VC object kind Class. 
It consists of an integer number surrounded by the brackets and a following extended identifier.

Examples for valid classnames:
{{{
(300)OpSys 
(200) car_kit4
(10)_gears
(100) 'Engines-SVU'
}}}

=== Keywords ===

Following character sequences are used as keywords in the VCML language and can not be used therefore as identifiers. They are case sensitive.
In addition, there are a number of two-character-sequences to define different languages for description and documentation. These are in line with SAP definitions.

==== *Keywords for VC Object declaration* ====
{{{
- billofmaterial			- material
- characteristic			- precondition
- class   				- procedure
- configurationprofile			- selectioncondition
- constraint				- variantfunction
- dependencynet				- varianttable 
- interfacedesign			- varianttablecontent
}}}


==== *Keywords for declaration of other objects/features and arguments* ====
{{{
- description				- characteristicgroup
- documentation				- configurationprofiles
- group   				- classes
- status				- billofmaterials
- type					- arguments
- configurationprofileentry		- format
- table					- field
- additionalValues			- displayAllowedvalues
- multiValue				- noDisplay
- notReadyForInput			- required
- restrictable				- negativeValuesAllowed
- intervalValuesAllowed			- caseSensitive
- key					- released
- inPreparation				- locked
- entry					- top-down
- bottom-up				- none
}}}

=== Operators ===

Operators in {{{.vcml}}}-files are _Extended Backus-Naur Form_-like (EBNF) expressions. They allow to describe object dependecies and value assignments.

The most important operators are the following:
 * {{{=}}} single assignment
 * {{{+=}}} multi value assignment
 * {{{?=}}} boolean assignment
 * {{{?}}} cardinality one or none
 * {{{*}}} cardinality any number
 * {{{+}}} cardinality at least once
 * cardinality exactly one is the default value and required no operator.
 * {{{()}}} groups expressions, like alternatives or numeric intervals
 * {{{!}}} inverts an oparator or excludes a value
 * {{{|}}} allows for multiple valid options as alternatives
 
Examples for usage of operators:
{{{
Material :
	'material' EXTENDED_ID ('{'								//material name is a mandatory single value EXTENDED_ID (no operator)
		Description											//the description is a mandatory single value (no operator), if the body is used, see operator ? at the and of the body definition
		type EXTENDED_ID									//type is a mandatory single value EXTENDED_ID (no operator), if the body is used, see operator ? at the and of the body definition
		'billofmaterials' '{' EXTENDED_ID* '}'?				// billofmaterial is an optional value EXTENDED_ID (? operator)
		'classes' '{' Classification* '}'?					//classes is an optional definition (? operator) which contains any number of classifications (* operator)
		'configurationprofiles' '{' EXTENDED_ID* '}'?		//configurationprofiles is an optional value EXTENDED_ID (? operator)
	'}')?													// the complete body is optional (? operator)

Classification
	CLASSNAME ('{' ValueAssignment* '}')?					//The classification name is a a mandatory single value CLASSNAME (no operator) which can optionally be followed by any number of value assignment definitions. 

ValueAssignment :
	EXTENDED_ID* '=' (NumericLiteral | SymbolicLiteral)+	//The value assignment can conatin any number of EXTENDED_IDs. Each EXTENDED_ID has a single assignment (=) to at least one (+) NumericLiteral or (|) SymbolicLitereal.
}}}

Example for a minimum material definition:
{{{
material CAR 
}}}

Example for a complete material definition:
{{{
material CAR {
	description "A configurable car"
	type KMAT
	classes { (300)CAR }
	billofmaterials { 'bom_car1' 'bom_car2'}
	configurationprofiles { 'profile_car1' 'profile_car2' }
}
}}}

=== Literals and Numeric Intervals===

Literals are used for value assignment. Two types of literals are defined:
 * Numeric literal, which can be positive or negative integer with or without decimal places. Additionally positive or negative exponents are allowed using the character {{{e}}}.
 * Symbolic literal, which can be a character sequence as described in [VCMLLanguage#Symbols Symbols]. Note that {{{F}}} and {{{T}}} are used as keywords for false and true (no and yes) literals in boolean context.
 
Examples for usage of literals:
{{{
characteristic colour {
	description "oulor of the car"
	symbolic {
		numberOfChars 30
		[]
	values { 'bk' { description "black" } 'wh' { description "white" } 'rd' { description "red" } }
}
status released
}

characteristic seatnumber {
	description "Number of seats"
	numeric {
	numberOfChars 1
	decimalPlaces 0
	[]
	values { 2 4 5 7 }
	}
status released
}

characteristic 'automatic_gear' {
	description "Selction of gear type"
	symbolic {
		numberOfChars 1
		[ caseSensitive ]
		values { 'F' { description "no" } 'T' { description "yes" } }
	}
status released
[ restrictable ]
}
}}}

To describe numeric intervals the hyphen character {{{-}}} is used between the lower bound number and the upper bound number. Additionally you can use standard operator cahracters to define interval boundaries according to your needs.

Examples for valid numeric intervals:
{{{
characteristic seatnumber {
	description "Number of seats"
	numeric {
	numberOfChars 1
	decimalPlaces 0
	[]
	values { 2 - 7 }
	}
status released
}
	
characteristic keynumber {
	description "Number of keys for the car"
	numeric {
	numberOfChars 2
	decimalPlaces 0
	[]
	values { <= 20 }
	}
status released
}
}}}