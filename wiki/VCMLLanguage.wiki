#summary VCML Language Documentation
#labels Featured,Phase-Design
#sidebar TableOfContents

= VCML Documentation =

_Please note that this documentation is still incomplete._
_Meanwhile, you can have a look into the parser definition file [http://code.google.com/a/eclipselabs.org/p/vclipse/source/browse/org.vclipse.vcml/src/org/vclipse/vcml/VCML.xtext VCML.xtext]_

Please note that this document is _not_ an introduction into SAP Variant Configuration.
The [http://help.sap.com/printdocu/core/print46c/en/data/pdf/LOVC/LOVC.pdf official documentation by SAP on LO-VC] or the book [http://www.sap-press.com/products/Variant-Configuration-with-SAP.html Variant Configuration with SAP] by Uwe Blumöhr, Manfred Münch, and Marin Ukalovic
as well as the SAP training courses provide introductory as well as in-depth information. 

== Introduction to VCML Model Structure ==

VCML provides a textual language to represent complete product models of the SAP Variant Configurator (LO-VC) or SAP IPC.

VCML source code is organized two different kinds of files:
 * files with extension {{{.vcml}}} contain all objects of a product model, e.g., characteristics, classes, configuration profiles, or dependency nets. 
 * files with extensions {{{.con}}}, {{{.proc}}}, {{{.sel}}}, and {{{.pre}}} contain the source code of dependencies of type _constraint_, _procedure_, _selection condition_, and _precondition_, respectively, in the respective language for dependencies as defined by SAP.

In the following the VCML file structure and the VCML-specific language syntax is described. 
Each {{{.vcml}}} file contains the textual representation of a VCML model. It is built of three basic building blocks: imports, options, and definitions of VC objects, as shown below:

{{{
VcmlModel :	
	Import*
	('options' '{' Option* '}')?
   	VCObject*
}}}

Note that these building blocks must be entered in the given order.

== Imports ==

The model can contain several import statements to import VC objects from other {{{.vcml}}} files.
The VC objects in the imported VCML files are then visible inside the importing VCML file. 

Applications:
 * Re-use of common data: information which is required for several or even all models can be stored in a central place and reused  wherever it is needed/applicable.
 * Create variants of a model: you can create variants of an existing model by importing the complete model and just modify several dedicated definitions. The original model is preserved. 
   Note: In this case all modifications done in the original model will automatically apply to the variant, too.

{{{
Import :
	'import' String
}}}
    
The import statement consists of the keyword 'import', followed by a String. This string represents the path to the source of the file or data which is to be imported. 
The path can be given as absolute path or as relative path with respect to the {{{.vcml}}} file.

Example of an import statement with absolute path:
{{{
import "platform:/resource/PROJECTNAME/FOLDERNAME/FILENAME.vcml"
}}}

Example of an import statement with relative path:
{{{
import "../../FOLDERNAME/FILENAME.vcml"
}}}

== Options ==

Optionally, a VCML model can contain one or more options. These options influence how objects are processed.

{{{
Option:
	Optiontype '=' String
}}}

An option definition starts with the option type, the equals '=' symbol, and the value of the option, given as a String.

Currently, the following options are defined:
 * {{{UPS}}}: When IDocs are created from the VCML document, the value of the UPS option is used as object key for the generated ALE distribution packet.
 * {{{ECN}}}: The value of the UPS option is used as change number for all objects.
 * {{{KeyDate}}}: The value of the KeyDate option is used as key date for all object.
 
== VC Objects ==

Each file can contain several top level VC objects.

=== Declaration of VC Objects ===

In the {{{.vcml}}} file the following kinds of VC objects can be defined:

{{{
VCObject : 
		BillOfMaterial
	|	Characteristic
	| 	Class
	| 	ConfigurationProfile
	| 	Constraint 
	| 	DependencyNet
	| 	InterfaceDesign
	| 	Material
	| 	Precondition 
	| 	Procedure 
	| 	SelectionCondition 
	| 	VariantFunction
	| 	VariantTable
	| 	VariantTableContent
}}}
	
The following table gives a short information about the purpose of each kind of VC object. For detailed information see the dedicated chapters in the [VCMLLanguage#List_of_VC_Objects].
|| *VC Object* || *Purpose* ||
|| [VCMLLanguage#BillofMaterial Bill of Material] || The BOM contains all items (materials) which are required to cover all variants of the product and assigns them to the product model. ||
|| [VCMLLanguage#Characteristic Characteristic] || The characteristics precisely define all selectable options or features of a configurable product, together with their feature values. Characteristics can be assigned object dependencies and/or restrictions to ensure that the configurations are consistent and complete, i.e. they only contain valid combinations of features and feature values. Characteristics can be used for static information (display only) as well as for variable options. These variable options again may or may not allow user input. ||
|| [VCMLLanguage#Class Class] || In the standard SAP R/3 the class type 300 is the class type for variants. In the {{{.vcml}}} file all characteristics defined for the product model are assigned to this class to enable their usage for material configuration.||
|| [VCMLLanguage#ConfigurationProfile Configuration Profile] || The configuration profile is mandatory for each configurable object. It contains general settings, like the product material??, the user interface design as well as standard networks (NPs) ?? and general procedures (PPs)?? which are to be used.Dependencies are also defined in the configuration profile.  The definitions depend on the object type. ||
|| [VCMLLanguage#Constraint Constraint] || Constraints monitor the consistency of a configuration. They describe dependencies between characteristics and contain information on which conditions must be fulfilled if the configuration is to be consistent.According to Sap R/3 constraints must belong to a dependency net. ||
|| [VCMLLanguage#DependencyNet Dependency Net] || The dependency net groups all constraints for the product model and provides like a single point of entry to the constraints of the whole configuration. ||
|| [VCMLLanguage#InterfaceDesign Interface Design] || The interface design supports grouping of characteristics to enable a structured layout. ||
|| [VCMLLanguage#Material Material] || Material is used to define name and type of every single configurable item of the product. Additionally, with material general features/relations?? Like type, assigned bill of materials, classes and configuration profiles which are used for the model are defined. ||
|| [VCMLLanguage#Precondition Precondition] || Preconditions support restricting or hiding of characteristics or characteristic values in case that they are only valid if the precondition is fulfilled. This ensures that configuration is consistent. ||
|| [VCMLLanguage#Procedure Procedure] || Procedures allow to internally/automatically modify values in the model. They can be assigned to characteristics, characteristic values, the configuration profile, BOM items and operations, which will then trigger a specified value change.||
|| [VCMLLanguage#SelectionCondition Selection Condition] || The assignment of a selection condition ensures that all objects required for a variant are selected. It can be assigned e.g. to characteristics and BOM items.  ||
|| [VCMLLanguage#VariantFunction Variant Function] ||  ||
|| [VCMLLanguage#VariantTable Variant Table] || A variant table supports restriction of characteristic values to valid combinations.  ||
|| [VCMLLanguage#VariantTableContent Variant Table Content] || Here the content of a variant table is defined.||

The minimum requirement for a configurable product is the definition of the material (for the product itself as well as for the individual items), a characteristic with selectable values and the assignment of a class and a configuration profile. By adding additional characteristics and other kinds of VC objects any product however complex can be modeled for variant configuration.

Each declaration of a VC object itself consists of the dedicated keyword as listed above, followed by the mandatory assignment of a name, and an optional body. 
The body can contain other objects or references to other VC objects defined elsewhere in the {{{.vcml}}} file.
There are some basic sublevel objects/features that are used in a number of VC objects while most sublevel objects/features are specific to a VC object. 
The identifiers and sublevel objects/features themselves are separately declared later on in the vcml file. Using this hierarchical declaration structure, all identifiers and sub level objects/features are defined only once and can be used/referenced by all other objects and VC objects.
For more information on the identifiers syntax and usage for the different VC objects see [VCMLLanguage#Identifier].
For more information on the common basic objects see [VCMLLanguage#Basic_options/Features].
For the declaration of the sublevel objects/features specific to VC objects, see the [VCMLLanguage#List_of_VC_Objects]. 


==== Descriptions ====

Nearly each VC object has a description.
Descriptions can be single-language descriptions or multi-language descriptions.

{{{
Description:
	SimpleDescription | MultiLanguageDescriptions
}}}

A single-language description is written as follows:
{{{	
SimpleDescription:
	'description' String
}}}

A multi-language description contains descriptions for multiple languages:
{{{
MultiLanguageDescriptions:
	'description' '{' (Language String)* '}'
	
Language:
	  AF | AR | BG | CA | CS | DA | DE | EL | EN | ES | ET | FI | FR | HE
	| HR | HU | ID | IS | IT | JA | KO | LT | LV | MS | NL | NO | PL | PT
	| RO | RU | SH | SK | SL | SR | SV | TH | TR | UK | Z1 | ZF | ZH
}}}
All SAP-supported ISO language codes can be used. 

An example for a single-language description is
{{{
description "the description of the VC object"
}}}

An example for a multi-language description is
{{{
description {
  EN "the description of the VC object"
  DE "die Beschreibung des VC-Objekts"
}
}}}

In the case of single-language descriptions, the default language defined in VClipse preferences is used, if specified. Otherwise the English language is used (EN).

Please note that descriptions are limited to 30 characters.
In case longer texts are required, you can use documentations.

==== Documentation ====

Several VC objects have a documentation.
Documentations can be single-language documentations or multi-language documentations.

{{{
Documentation:
	SimpleDocumentation | MultiLanguageDocumentations
}}}

A single-language documentation is written as follows:
{{{	
SimpleDocumentation:
	'documentation' String
}}}

Multi-language documentations are slightly more complicated than descriptions, since documentations may contain
multiple text blocks with attached format information.

Multi-language documentations contain documentations for multiple languages:
{{{
MultiLanguageDocumentations:
	'documentation' '{' (Language String ('format' String)? )* '}'
}}}

An example for a single-language documentation is
{{{
documentation "the documentation of the VC object"
}}}

An example for a multi-language documentation is
{{{
documentation {
  EN "the documentation of the VC object"
  DE "die Dokumentation des VC-Objekts"
}
}}}

<wiki:comment>
### give another example which uses format
</wiki:comment> 

{{{
documentation {
  EN "the documentation of the VC object" 
  DE "die Dokumentation des VC-Objekts"
}
}}}

In the case of single-language documentations, the default language defined in VClipse preferences is used, if specified. Otherwise the English language is used (EN).

==== Status ====

Many VC objects can have a status.

A status is written as follows:
{{{	
Status:
	'status' ('released' | 'inPreparation' | 'locked')
}}}

An example for a status is
{{{
status released
}}}

==== Group ====

These VC objects can also be assigned to groups.
In the SAP systems, groups are defined in customization and thus have a restricted range of possible values.
In VCML, they are written as strings and are therefore not restricted.

A group is written as follows:
{{{
Group:
	'group' String
}}}

An example for a group is
{{{
group "PRODUCTS_CAR"
}}}

The length of a group is restricted to 10 characters.

== List of VC objects ==
??Additionally, one or more objects have to be assigned with VC objects, which in turn can contain (sub level) objects or reference to other top level VC objects.
//VC objects ohne body sind z.B. für generische 
=== Characteristic ===
Characteristics are used to describe precisely of which elements a product is made of, and which values these elements can have.

A characteristic is written as follows:
{{{
Characteristic =
  'characteristic' ID ( '{'
     Description
	 Documentation?
	 CharacteristicType
     Status?
   	 Group?
	 CharacteristicAdditionalProperties?
	 CharacteristicOrValueDependencies?
  '}' )? 	

CharacteristicAdditionalProperties = 
  '[' 'additionalValue'?
      'required'?
      'restrictable'?
      'noDisplay'?
      'notReadyForInput'?
      'multiValue'?
      'displayAllowedValues'?  
  ']'
}}}

Currently, only numeric and symbolic characteristics are possible.
The other characteristic types possible in SAP like date or ADT are not yet implementd in VCML.

{{{
CharacteristicType = NumericType | SymbolicType
}}}

A !NumericType is written as follows:
{{{	
NumericType =
  'numeric' '{'
     'numberOfChars' INT
     'decimalPlaces' INT
	 ('unit' String)?
     NumericAdditionalProperties?
     ('values' '{' NumericCharacteristicValue* '}' )?
  '}'

NumericAdditionalProperties = 
  '[' 'negativeValuesAllowed'?
      'intervalValuesAllowed'?  
  ']'

NumericCharacteristicValue = NUMBER CharacteristicOrValueDependencies?
}}}


A !SymbolicType is written as follows:
{{{	
SymbolicType =
  'symbolic' '{'
     'numberOfChars' INT
     SymbolicAdditionalProperties?
     ('values' '{' CharacteristicValue* '}' )?
  '}'

SymbolicAdditionalProperties = 
  '[' 'caseSensitive'? ']'

CharacteristicValue =
  SYMBOL ('{' 
    Description? 
    Documentation? 
    CharacteristicOrValueDependencies?
  '}')?
}}}

An example for a characteristic is
{{{
characteristic ENGINE {
  description "the possible engines for a car"
  numeric { 
    numberOfChars 4
    decimalPlaces 0
    values {1500 1800 2100 2400}
  } 
  status released
  group "PRODUCTS_CAR"
}
}}}

Dependencies, i.e. conditions, procedures, or constraints can be attached to characteristics or characteristic values.

CharacteristicOrValueDependencies are written as follows:
{{{	
CharacteristicOrValueDependencies =
  'dependencies' '{'
     ID*
  '}'
}}}
The {{{ID}}} name the attached depedencies.

<wiki:comment>
### This is an example for local dependencies
An example for CharacteristicOrValueDependencies is:
{{{
	dependencies {
		precondition {
            description "precondition for gears"
            PRODUCTS_CAR
            source { $SELF.GEAR in ('4-gear', '4-gear automatic')       
                       if $ROOT.ENGINE IN ('1500', '1800') 
                    }		
        }
		
		selectioncondition {
            description "selection condition for gears"
            source { $SELF.GEAR SPECIFIED 
                     if $ROOT.ENGINE SPECIFIED 
            }
        }
		
		// global dependencies like procedure, selection condition, or precondition 

		PRECOND  // see [VCMLLanguage#Precondition]
		SEL_COND // see [VCMLLanguage#Selection_Condition]
	}
}}}
</wiki:comment>

=== Class ===

The main purpose of classes is to reference characteristics and attach them to materials of the model (see also [VCMLLanguage#Material Material]). 

A class is defined as follows:
{{{
Class:
    'class' CLASSNAME ('{'
    	Description
    	Status?
    	Group?
    	'characteristics' '{' XID* '}'
    	('superclasses' '{' CLASSNAME* '}')?
	'}')?

CLASSNAME = '(' INT ')' XID
}}}

A class definition starts with the keyword {{{class}}} followed by a {{{CLASSNAME}}}. 
The {{{CLASSNAME}}} consists of an integer number set in brackets defining the class type and an {{{XID}}} defining the name of the class.
The class type must be valid for usage in variant configuration, like (300).

The class can be enhanced by an optional body.
 
If the body is added, a {{{Description}}} is a mandatory feature while {{{Status}}} and {{{Group}}} are optional.
All {{{characteristics}}} must be referenced here with their name, textually represented as an {{{XID}}}.
The number of characteristics in one class is restricted to 999. This total number of characteristics can be extended by adding references to superclasses, since a class inherits all characteristics of its superclasses.
Additionally, {{{superclasses}}} can be referenced with their {{{CLASSNAME}}} which is defined as described above.
The entries for the optional features can be made in any order.

A class definition without body can be used e.g. to include general classes in the product model which are defined somewhere else.

Example for a class definition without body stating only the classname:
{{{
class (300)CAR
}}}

Example for a class definition including all optional features:
{{{
class (300)CAR {
	description "this is the class for the car"
	status released
	group "PRODUCTS_CAR"
	characteristics {
		ENGINE
		GEAR
		COLOUR
		INTERIOR
	}
	superclasses { (300)VEHICLE }
}
}}}

=== Constraint === 

A constraint is defined as follows:
{{{
Constraint =
  'constraint' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConstraintSource '}' )?
  '}')?  
}}}

{{{ConstraintSource}}} is the source code of the constraint.
The syntax of the source code is exactly defined like in SAP.

Example for a constraint declaration:
{{{
constraint CS_CAR1 {
  description "Possible interior for the smallest engine"
  status released
	group "PRODUCTS_CAR"
	source {
	  OBJECTS: CAR IS_A (300)CAR
      CONDITION: CAR.ENGINE = '1500'
      RESTRICTION: CAR.INTERIOR IN ('01', '02')
	}
  }
}}}

=== Dependency Net ===
A dependency net is defined as follows:
{{{
DependencyNet =
  'dependencynet' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ID*
  '}')?  
}}}

The first ID defines the name of the dependency net,
the second ID are the names of the constraints of the dependency net.

Example for a dependency net declaration:
{{{
dependencynet DEP_NET {
  description "This is a constraint net for the car"
  documentation "documentation"
  status released
  group "PRODUCTS_CAR"
  CSTRT
  CS_CAR1
}
}}}

=== Interface Design === 
An interfacedesign is defined as follows:
{{{
InterfaceDesign =
  'interfacedesign' ExtendedIdentifier ('{'
    CharacteristicGroup*
  '}')?  

CharacteristicGroup =
  'characteristicgroup' ExtendedIdentifier '{'
    Description
    ID*
  '}'
}}}

The ID in a characteristic group refers to a characteristic.

Example for an interface design declaration:
{{{
  interfacedesign INT_DESIGN {
	characteristicgroup FunEl {
	  description "functional elements"
	  ENGINE
      GEAR
    }
	characteristicgroup DesignEl {
      description "design elements"
      COLOUR
      INTERIOR
    }
  }
}}}


=== Material === 

A material is used to define name and type of both a whole product which itself consists of several configurable items as well as every single line item.
For example both the car and all available parts as engines, gears, colors, etc. are declared as material. 
For product material, besides name and type general features can be added, like the assignment of classes, classification, bill of materials, and configuration profiles which apply to the product.
Please note, that material objects have no documentation, group, and status features. 

A material is defined as follows:
{{{ 
Material :
	'material' EXTENDED_ID ('{'
		Description
		type ID
		'billofmaterials' '{' EXTENDED_ID* '}'?
		'classes' '{' Classification* '}'?
		'configurationprofiles' '{' EXTENDED_ID* '}'?
	'}')?

Classification
	CLASSNAME ('{' ValueAssignment* '}')?

ValueAssignment :
	XID* '=' (NumericLiteral | SymbolicLiteral)+
}}}

A material definition starts with the keyword {{{material}}} followed by an {{{EXTENDED_ID}}} defining the name of the material.

The material definition can be enhanced by an optional body.

If the body is, {{{description}}} and {{{type}}} are mandatory features. The type is defined by an identifier ({{{ID}}}), typical types are {{{KMAT}}} (configurable material) or {{{HAWA}}} (trading goods).    
Additionally, {{{billofmaterials}}}, {{{configurationprofile}}} and {{{classes}}} can be referenced. 
These features are required when specifying the material of a complete product, see also example below.

By referencing the bill of material all configurable items available for the product are assigned to the product as BOM items. Thus the bill of material is like a master BOM. The items valid for a specific variant configuration are picked from this master BOM.
For detailed information see [VCMLLanguage#Bill_of_Material Bill of Material].
Adding configuration profiles to a material allows to define general settings and further object dependencies. For detailed information see [VCMLLanguage#Configuration_Profile Configuration Profile].
The references to classes allow to classify the product material with a set of classes. Additionally, values can be assigned to characteristics by means of classification.

The entries for the optional features can be made in any order.

Example for a material declaration for a product, i.e. including a bill of material, a class, and a configuration profile:

{{{ 
material CAR {
	description "A configurable car"
	type KMAT
	classes { (300)CAR }
	billofmaterials { 'bom_car' }
	configurationprofiles { 'profile_car' }
}
}}}

Example for a material declaration for line items without any optional features:
{{{
material Engine_1500 {
	description "Small engine"
	type HAWA
}

material Engine_2400 {
	description "Big engine"
	type HAWA
}
}}}

=== Bill of Material ===

The bill of material is a list of configurable items.
The bill of material must be defined for the complete product, which is then the master BOM for all product variants. 
This master BOM can directly list every single item of the product, see example 1, or list other BOMs for groups of items, like BOMs for engine, gear, etc. as shown in example 2. 
You can also mix single items and BOMs in a BOM declaration.
To distinguish between mandatory material and variable, i.e. configurable material, the object/feature selection condition is used. 
Declaration of a selection condition makes the material a variable part, i.e. it will only be added to the product if a specified condition is fullfilled. 

A bill of material is declared as follows:
{{{
BillOfMaterial:
	'billofmaterial' EXTENDED_ID ('[' Option* ']')? '{'
		'material' '{'EXTENDED_ID'}?
		'items' '{' BOMItem* '}'?
	'}'

BOMItem:
	BOMItem_Material | BOMItem_Class

BOMItem_Material:
	INT EXTENDED_ID
	('dependencies' '{'
		EXTENDED_ID?
	 	ConfigurationProfileEntry*
	'}')?

BOMItem_Class:
	INT CLASSNAME
	('dependencies' '{'
		EXTENDED_ID?
	 	ConfigurationProfileEntry*
	'}')?
}}}

The bill of material consists of the keyword {{{billofmaterial}}} followed by the name of the bill of material, textually represented as an {{{EXTENDED_ID}}}, and the features.   

There are tow optional features, {{{material}}} and {{{items}}}.
The material referenced here is the material of the product, consisting of the keyword {{{material}}} followed by the name of the corresponding material.
The feature items consists of the keyword {{{items}}} followed by a list of all BOM items, i.e. all configurable items belonging to the product.

BOM items can either be materials or classes (class nodes).

In turn each configurable BOM item is itself defined as a material. It consists of an integer number {{{INT}}}, representing the item number. This is followed by the name of this dedicated item, textually represented as an {{{EXTENDED_ID}}}.

... something about class nodes ...

Optionally dependencies can be added, giving the reference to a selection condition, see [VCMLLanguage#Selection_Condition Selection Condition], and to procedures.

Example 1 for BOM with single items:
{{{
billofmaterial 'bom_car' {
	material 'CAR'
	items {
	  10	Engine_1500
	  dependencies {  sel cond. and/or procedure	      }	       ???
	  20	Engine_1800
	   dependencies {    ??		 }	  ???
	  30	Engine_2100
	   dependencies {    ??		 }	  ???
	  40	Engine_2400
	   dependencies {    ??		 }	  ???
	  50	Gear_4
	  60	Gear_4automatic
	  70	Gear_5
	  80	Gear5automatic
	  90	Interior_01
	  100	Interior_02
	  110	Interior_03
	  120	Colour_black
	  130	Colour_white
	  140	Colour_red
	}
  }
}}}
Example 2 for BOM with further BOMs and single item:
{{{
billofmaterial 'bom_car' {
	material 'CAR'
	items {
	  10	bom_engine
	  20	bom_gear
	  30	bom_interior
	  40	bom_colour
	  50	stereo
	  60	navigation system
	}
  }
  billofmaterial 'bom_engine' {
	material 'engine'
	items {
	  10	Engine_1500
	  dependencies {    ??		}	 ???
	  20	Engine_1800
	   dependencies {    ??		 }	  ???
	  30	Engine_2100
	   dependencies {    ??		 }	  ???
	  40	Engine_2400
	   dependencies {    ??		 }	  ???
	}
  }
  billofmaterial 'bom_gear' {
	material 'gear'
	items {
	  10	Gear_4
	  20	Gear_4automatic
	  30	Gear_5
	  40	Gear5automatic
	}
  }
  billofmaterial 'bom_interior' {
	material 'interior'
	items {
	  10	Interior_01
	  20	Interior_02
	  30	Interior_03
	}
  }
    billofmaterial 'bom_colour' {
	material 'colour'
	items {
	  10	Colour_black
	  20	Colour_white
	  30	Colour_red
	}
  }
}}}

=== Configuration Profile ===

The configuration profile is defined as follows:
{{{
ConfigurationProfile 
	:
    'configurationprofile' EXTENDED_ID ('[' options+=Option* ']')? '{'
	   (	('material' '{'EXTENDED_ID'})?
	   		('status' Status)?
	   		('bomapplication' XID)?
	   		('uidesign' '{'EXTENDED_ID'})?
	    	('fixing' Fixing)?
	   )
       ('DependencyNet' '{'EXTENDED_ID'}])*
       (ConfigurationProfileEntry)*
    '}'
    
ConfigurationProfileEntry :
    INT EXTENDED_ID
             
}}}  
The configuration profile consists of the keyword {{{'configurationprofile'}}}, followed by the name of the profile, textually represented as an {{{EXTENDED_ID}}}, and the features.  
Optionally, the material of the product and a ui design can be referenced, and a status, a BOM application and a Fixing can be defined.
Describe bom application!
Describe fixing!
Additionally, dependency nets are referenced and configuration profile entries ?? listed.
The configuration profile entry is defined by an integer referring to the sequence of the entry and a reference to a procedure, textually represented as an {{{EXTENDED_ID}}}, 






== Precondition ==
A precondition is defined as follows:
{{{
Precondition =
  'precondition' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConditionSource '}')?
  '}')?
}}}

ConditionSource is the source code of the precondition, exactly as defined in SAP.

An example for a precondition
{{{
precondition PRECOND {
  description "description"
  documentation "documentation"
  status released
  group "group"
  source { $SELF.GEAR in ('4-gear', '4-gear automatic')       
           if $ROOT.ENGINE IN ('1500', '1800') }
}
}}}

== Procedure ==
A procedure is defined as follows:
{{{
Procedure =
  'procedure' ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ProcedureSource '}')?
 '}')?
}}}

ProcedureSource is the source code of the procedure, exactly as defined in SAP.

Example for a procedure:
{{{
procedure PROC {
  description "set interior quantity"
  documentation "documentation"
  status released
  group "PRODUCTS_CAR"
  source { $self.C_QUANT = 2 if $root.ENGINE = '1500' }
}
}}}

== Selection Condition == 
A selection condition is defined as follows:
{{{
SelectionCondition =
  'selectioncondition'  ID ('{'
    Description
    Documentation?
    Status?
    Group?
    ('source' '{' ConditionSource '}')?
  '}')?
}}}

ConditionSource is the source code of the selection condition, exactly as defined in SAP.

Example for selection condition:
{{{
selectioncondition SEL_COND {
  description "description"
  documentation "documentation"
  status released
  group "group"
  source { $SELF.GEAR SPECIFIED if $ROOT.ENGINE SPECIFIED }
}
}}}

== Variant Function ==
Only the interface of a VariantFunction is defined here.
ABAP respectively Java code is not defined in VCML.

A variant function is defined as follows:
{{{
VariantFunction =
  'variantfunction'   ('{'
    Description
    Status?
    Group?
    ('arguments' '{' VariantFunctionArgument* '}' '}')?
    
VariantFunctionArgument = 'in'? ID
}}}

If the keyword {{{in}}} is given the following ID refers to an input characteristic.
Otherwise the ID belongs to an output characteristic.

Example for a variant function:
{{{
variantfunction VAR_FUNC {
  description "description"
  group "group"
  status locked
  arguments {
	in ENGINE 
	in GEAR 
	FUELCONSUMPTION   
  }
}
}}}

== Variant Table ==

The structure (scheme) of a variant table is defined as follows:
{{{
VariantTable =
  'varianttable' ID ('{'
    Description
    Status?
    Group?
    ('arguments' '{' VariantTableArgument* '}') '}')?
    
VariantTableArgument = 'key'? ID
}}}

The keyword {{{key}}} is used to mark the key columns. The ID refers the appropriate columns.

Example for a variant table:
{{{
varianttable VAR_TAB {
  description "description"
  group "group"
  status inPreparation
  arguments {
	key INTERIOR
	COLOUR
  }
}
}}}

== General Language Constructs ==

=== Whitespace ===

Whitespace is irrelevant.

=== Comments ===

VCML offers single-line comments and block comments.
They are written like in Java or C:
{{{
// this is a single line comment
    // this is another single line comment which does not start in the first column
/* this is a 
block comment
*/
}}}
Block comments may not be nested.

=== Strings ===

Strings are character sequences enclosed in double quotes.
Escape sequences starting with \ allow to write strings containing
e.g. the newline or tab character or the double quote character.
The contents of strings is case sensitive.

Sample strings are:
{{{
"" // the empty string
"A sample string"
"A SAMPLE STRING" // another sample string, different from the string before
"This is a tab\tand this is a newline\ncharacter" // a string containing a tab and a newline character
"This is a string containing \"quotes\""
"\\ can be escaped by writing the backslash character twice"
"The line comment character sequence // does not introduce a comment in strings"
}}}  

Strings are used for example to represent the description of a VC object:
{{{
material software {
	description "This is a string"
	...
}
}}}


=== Symbols ===

Symbols are character sequences which are enclosed in single quotes.
Escape characters are not allowed.
Symbols are case-insensitive. 
<wiki:comment>
### clarify this
</wiki:comment>

Symbols are used for example as names of characteristic values or names of configuration profiles or interface designs.


They are used for example for naming of configuration 
profile objects:
{{{
material software {
	description "Operating system to be delivered"
	type os
	// 'ubuntu' is a symbol
	configurationprofile 'ubuntu' {
		status released
		bomapplication SD02
		uidesign 7
	}
	// 'knoppix' is a symbol
	configurationprofile 'knoppix' {
		status inPreparation
		bomapplication SD03
		uidesign b
	}
}
}}}

Symbols can be empty.
<wiki:comment>
### clarify this
</wiki:comment>




=== Identifier ===
Three different types of identifiers are specified for VCML language. All VC objects, except Classes, Materials and InterfaceDesigns, can be named with simple identifiers. Please use the 
class identifier to give a name to a class.
==== Simple Identifier ====
Simple identifiers are used for example as names for characteristics, classes??, or dependencies. 
Simple identifier are character sequence beginning with a character (only 
ASCII characters are allowed) or underscore and containing lower/upper characters, underscore 
or numbers.
Examples:
{{{
_76
Ubuntu
wIndOWs_7
}}}
<wiki:comment>
### verify whether _76 is an identifer in SAP
### give an example where different cases represent the same identifier.
</wiki:comment>

Identifiers are case insensitive.

 


=== Extended identifier ===

Extended identifiers are used for example for interface designs objects and material.
Extended identifiers are character sequences consisting of integer numbers, characters, which
are parts of identifiers or the following characters: / : - and dot.
Extended identifier can not be empty. They are used for example in interface designs declarations:
{{{
	interfacedesign ...
	interfacedesign 78bWd
	interfacedesign /:-54w
	
}}}
  
=== Class identifier ===

Class identifier consist of a number surrounded by the brackets and a following identifier.
Examples:
{{{
	(300)OpSys 
	(200)car_kit4
}}}

=== Operators ===

=== Literals ===

=== Keywords ===

Following character sequences are used as keywords in the VCML language and can not be used therefore as identifiers:
<wiki:comment>
### the language should be extended such that these character sequences can be used as identifiers

### there are more keywords, e.g. description, documentation, status, group, ...
</wiki:comment>

==== *Keywords for VCObject declaration* ====
{{{
  - characteristic           - dependencynet
  - class                    - material
  - constraint               - interfacedesign
  - selectioncondition       - variantfunction
  - precondition             - varianttable
  - procedure
}}}
